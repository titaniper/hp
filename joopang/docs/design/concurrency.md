## 동시성 제어 전략 비교

본 문서는 주팡 서비스(주문·결제, 쿠폰 발급, 장바구니 등)에서 적용 가능한 대표적인 동시성 제어 기법을 정리하고, 각 기법의 장단점·적용 시나리오를 비교한다.

## 1. 낙관적 락 (Optimistic Locking)

| 구분 | 상세 |
| --- | --- |
| 핵심 아이디어 | 트랜잭션 충돌이 드물다고 가정하고, 커밋 직전에 버전(Version) 또는 타임스탬프를 비교한다. 불일치 시 재시도 또는 실패 처리. |
| 구현 방법 | RDB의 `version` 칼럼 + JPA `@Version`, Cassandra LWT(Lightweight Transaction) 등 |
| 장점 | 별도의 락 자원 없이 처리 → 높은 처리량, 스레드/인스턴스 확장에 유리 |
| 단점 | 충돌 발생 시 전체 트랜잭션을 다시 수행해야 하므로 고경쟁 구간에서는 재시도 비용 급증 |
| 적용 추천 | `OrderService.reserveStock`에서 재고 차감, `CouponService.issueCoupon`에서 사용자 한도 체크 등 “실패 시 재시도 허용”인 비즈니스 로직 |
| 주의점 | 재시도 시 멱등성 보장 필요, 재시도 횟수 제한과 백오프 정책 필요, 충돌 빈도가 높은 SKU는 다른 전략과 혼용 |

## 2. 비관적/분산 락 (Pessimistic Lock & Distributed Lock)

| 구분 | 상세 |
| --- | --- |
| 핵심 아이디어 | 자원을 선점(lock)한 뒤 작업을 수행하여 충돌 자체를 차단 |
| 구현 방법 | RDB `SELECT ... FOR UPDATE`, Redis 분산 락(Redisson `RLock`, SET NX + Lua 스크립트), ZooKeeper/etcd |
| 장점 | 충돌이 잦은 구간에서도 안정적, 재시도 비용 최소화, 순서 보장이 쉬움 |
| 단점 | 락을 오래 점유하면 대기 시간이 길어지고, 장애 시 락 해제 로직이 필요. 분산 락은 네트워크 지연/시간 동기화 문제 고려 필요 |
| 적용 추천 | `ProductLockManager` 구현체로 Redis 분산 락을 도입하여 주문 생성 시 SKU 단위 재고 차감 보호, 선착순 쿠폰처럼 “하나씩 처리”해야 하는 로직 |
| 주의점 | 락 점유 시간 제한(TTL)과 자동 연장 정책 필요, 실패 시 락 해제 보장(try/finally, Lua 스크립트), 긴 트랜잭션은 락 단위 세분화 또는 큐 처리로 전환 |

## 3. 멱등 토큰 + 비동기 큐 (Idempotency Key + Async Queue)

| 구분 | 상세 |
| --- | --- |
| 핵심 아이디어 | 요청을 즉시 처리하지 않고 큐에 적재, 워커가 순차적으로 처리. API는 `Idempotency-Key`로 중복 요청을 제거 |
| 구현 방법 | HTTP 헤더 `Idempotency-Key` + Redis/Mongo 등에서 요청 히스토리 관리, Kafka/Redis Streams/메시지 큐 기반 워커 처리, Outbox 패턴 결합 |
| 장점 | 트래픽 급증 시 백프레셔 가능, 작업 순서/중복 제어 용이, 장애 시 재처리 용이 |
| 단점 | 처리 지연(비동기), 큐/워크플로 관리 비용 증가, 상태 추적 저장소 필요 |
| 적용 추천 | 결제/환불, 대량 쿠폰 발급 이벤트, 통계 집계처럼 “즉시 응답보다 일관성·재시도”가 중요한 비동기 처리 영역 |
| 주의점 | 클라이언트에게 비동기 처리 사실(예: 202 Accepted) 안내, 워커 장애 대비 재시도/Dead Letter Queue 필요, Outbox와 도메인 트랜잭션의 원자성 확보 |

## 4. 시나리오별 의사결정 가이드

| 시나리오 | 요구사항 | 권장 전략 | 보조 전략 |
| --- | --- | --- | --- |
| 재고 차감 (복수 고객 동시 구매) | 강한 일관성, 짧은 처리 시간 | Redis 분산 락 (`ProductLockManager`) | 락 획득 실패 시 낙관적 락 재시도 |
| 쿠폰 선착순 발급 | 강한 일관성 + 높은 경쟁률 | 분산 락 또는 Redis SET NX | 실패 시 낙관적 재시도, 멱등 키 |
| 장바구니 수량 업데이트 | 사용자 당 낮은 경쟁 | 낙관적 락 | 필요 시 상품별 락 |
| 결제/환불, 아웃박스 이벤트 | 재처리 가능, 즉시성↓ | 멱등 키 + 큐/워커 | DB 트랜잭션 + Outbox 원자화 |

## 5. 운영 시 고려 사항

1. **락 모니터링**: Redis/DB 락 대기 시간, 타임아웃율을 메트릭으로 수집하여 핫 SKU 감지 및 알림.
2. **재시도/백오프 정책**: 낙관적 락 실패 시 지수 백오프와 최대 시도 횟수를 정의하고, 사용자에게 재시도 안내 메시지를 제공.
3. **멱등성 확보**: 모든 재시도 가능 API는 요청 ID/멱등 키를 포함해 중복 처리를 방지하고, 실패 이벤트를 DLQ에 남겨 감사 가능하도록 한다.
4. **동시성 테스트**: 멀티 스레드/프로세스 테스트와 Chaos 테스트(락 서비스 장애, 네트워크 지연)를 주기적으로 수행.

## 6. 결론

- **재고·쿠폰처럼 강한 일관성이 필요한 핵심 구간**은 분산 락으로 보호하고, 락 획득 실패 시 낙관적 락 재시도로 응답을 빠르게 복원한다.
- **경쟁이 낮거나 실패 후 재시도가 허용되는 로직**은 낙관적 락으로 간결하게 처리하여 시스템 처리량을 확보한다.
- **결제/환불 및 배치형 처리**는 멱등 키와 비동기 큐를 결합해 백프레셔와 재시도 전략을 제공한다.

이러한 조합을 통해 Joopang 서비스는 동시성 높은 구간에서도 안정적인 일관성과 확장성을 동시에 달성할 수 있다.
