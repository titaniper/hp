## 1. 분산 락과 재고 처리 (Distributed Lock & Inventory)

**Q1.** 선착순 이벤트나 타임 세일 같은 고트래픽 상황에서 재고 차감을 위해 **Redisson 분산 락**을 적용했습니다. 하지만 락 획득 대기 시간이 길어지면 전체 응답 속도가 느려지는 문제가 우려됩니다. 실무에서는 재고 처리를 위해 분산 락 외에 **Redis의 `DECR` 같은 Atomic 연산**만으로 재고를 관리하고, 비동기로 DB에 반영하는 방식(Write-Back)을 사용하기도 하나요? 이때 데이터 불일치 리스크는 어떻게 관리하시나요?

## 2. 캐시 스탬피드와 핫딜 상품 (Cache Stampede)

**Q2.** '블랙 프라이데이' 같은 대형 이벤트 시 특정 인기 상품 페이지에 트래픽이 몰릴 때, 캐시 만료 시점의 DB 부하(Cache Stampede)가 걱정됩니다. **PER(Probabilistic Early Recomputation)** 알고리즘이나 **Mutex Lock**을 학습했는데, 실제 커머스 운영 환경에서 가장 효과적이었거나 선호하시는 패턴이 있으신가요?

## 3. 캐시 정합성과 쓰기 전략 (Cache Consistency)

**Q3.** 상품 가격이나 재고처럼 데이터 정합성이 중요한 정보는 **Write-Through**가 안전해 보이지만 쓰기 성능이 걱정되고, **Write-Back**은 성능은 좋지만 유실 위험이 있어 보입니다. 멘토님께서는 **주문/결제와 직결된 중요 데이터**의 캐싱 전략을 어떻게 가져가시는지, 그리고 정합성이 깨졌을 때의 보상 트랜잭션이나 복구 프로세스는 어떻게 구축하시는지 궁금합니다.

## 4. 분산 락과 트랜잭션의 범위 (Lock & Transaction Scope)

**Q4.** 분산 락을 사용할 때 `락 획득 -> 트랜잭션 시작 -> 로직 -> 트랜잭션 커밋 -> 락 해제` 순서를 지켜야 동시성 이슈가 없다고 배웠습니다. 하지만 이렇게 하면 락을 잡고 있는 시간이 길어져 성능 저하가 발생할 것 같습니다. 실무에서는 **락의 범위를 최소화**하기 위해 어떤 기법(예: 퍼사드 패턴 등)을 주로 사용하시나요?

## 5. Redis 클라이언트 선택 (Lettuce vs Redisson)

**Q5.** Spring Boot 기본인 **Lettuce**는 성능이 좋지만 분산 락 구현이 번거롭고, **Redisson**은 락 구현은 편하지만 무겁다는 평이 있습니다. 현재는 두 라이브러리를 혼용해서(일반 캐싱은 Lettuce, 락은 Redisson) 사용하려고 하는데, 실제 대규모 커머스 환경에서도 이런 **하이브리드 방식**이 일반적인지, 아니면 운영 복잡도를 줄이기 위해 하나로 통일하는 추세인지 궁금합니다.

## 6. 로컬 캐시와 글로벌 캐시의 조화 (Local vs Global Cache)

**Q6.** 카테고리 목록이나 공통 코드처럼 변경이 거의 없는 데이터는 **로컬 캐시(Ehcache/Caffeine)**가 성능상 유리해 보입니다. 하지만 서버 간 데이터 불일치(Consistency) 문제가 신경 쓰입니다. 실무에서는 **Redis Pub/Sub** 등을 이용해 로컬 캐시 동기화를 구현하시나요, 아니면 관리 포인트 증가를 막기 위해 무조건 **Redis(Global Cache)**만 사용하시나요?

## 7. 분산 트랜잭션과 Saga 패턴 (Distributed Transaction)

**Q7.** 마이크로서비스 아키텍처(MSA)로 전환 시 주문-결제-배송 간의 트랜잭션 관리가 어려워 **Saga 패턴**을 공부했습니다. 하지만 보상 트랜잭션 구현 복잡도가 너무 높아 보입니다. 커머스 도메인에서 **실제 강한 일관성(2PC)**이 반드시 필요한 구간과 **결과적 일관성(Saga)**으로 타협 가능한 구간을 나누는 멘토님만의 기준이 있으신가요?

## 8. Redis 운영 및 장애 대응 (Redis HA)

**Q8.** Redis가 다운되면 서비스 전체 장애로 이어질 수 있다는 점이 두렵습니다. 실무에서는 Redis 장애 시 **DB로 Fallback**하는 로직을 모든 조회 코드에 넣으시나요? 아니면 Redis Cluster나 Sentinel 같은 고가용성(HA) 구성만 믿고 가나요? 장애 발생 시 "서킷 브레이커" 설정 팁이 있다면 듣고 싶습니다.

## 9. 캐시 만료 및 방출 정책 (Expiration & Eviction)

**Q9.** 쇼핑몰에는 '최근 본 상품', '장바구니', '베스트 랭킹' 등 성격이 다른 데이터가 많습니다. Redis 메모리 관리를 위해 `maxmemory-policy`를 설정해야 하는데, **LRU**와 **LFU** 중 커머스 환경에서 더 효율적인 정책은 무엇인가요? 혹은 데이터 타입별로 Redis 인스턴스를 분리해서 운영하기도 하나요?

## 10. 모니터링과 지표 (Monitoring)

**Q10.** Redis를 도입한 후 성능 모니터링을 하려는데, 단순히 `Hit Rate`만 보면 될지 모르겠습니다. 커머스 서비스의 안정적인 운영을 위해 **반드시 주시해야 할 Redis 핵심 지표**(예: Slowlog, Connected Clients, Fragmentation Ratio 등)와 임계치 설정 노하우가 궁금합니다.

## 11. 캐시 키 설계 및 네임스페이스 전략 (Cache Key Design)

**Q11.** 쇼핑몰에서 상품 정보, 카테고리, 사용자별 장바구니 등 다양한 데이터를 캐싱하다 보니 키 충돌이나 관리가 복잡해지고 있습니다. **캐시 키 네이밍 컨벤션**(예: `product:{id}`, `category:{id}:products`)을 어떻게 설계하시는지, 그리고 상품 정보가 업데이트될 때 관련된 모든 캐시(상품 상세, 카테고리별 목록, 검색 결과 등)를 효율적으로 무효화하는 전략이 궁금합니다. 특히 **태그 기반 무효화(Tag-based Invalidation)**나 **이벤트 기반 무효화** 방식을 실무에서 사용하시는지요?

## 12. 멀티 레벨 캐싱 전략 (Multi-Level Caching)

**Q12.** 인기 상품 조회 API의 응답 속도를 더 개선하고 싶어 **로컬 캐시(Caffeine) + Redis** 2단계 캐싱을 고려 중입니다. 하지만 로컬 캐시와 글로벌 캐시 간의 데이터 불일치 문제가 걱정됩니다. 실무에서는 멀티 레벨 캐싱을 어떤 시나리오에서 사용하시며, 로컬 캐시의 TTL을 어떻게 설정하시나요? 또한 **로컬 캐시가 먼저 만료되도록 짧게 설정**하는 것이 일반적인 패턴인지 궁금합니다.

## 13. Redis Cluster vs Sentinel 선택 기준 (High Availability)

**Q13.** Redis 고가용성 구성을 위해 **Cluster 모드**와 **Sentinel 모드** 중 어떤 것을 선택해야 할지 고민입니다. Cluster는 샤딩을 통해 수평 확장이 가능하지만 복잡도가 높고, Sentinel은 단순하지만 수직 확장에 의존합니다. 커머스 서비스에서 **트래픽 증가 예상치**나 **데이터 크기**를 기준으로 선택하시는 멘토님만의 기준이 있으신가요? 또한 두 방식의 **운영 복잡도 차이**와 **장애 복구 시간** 차이도 궁금합니다.

## 14. 캐시 워밍업 및 초기 로딩 전략 (Cache Warming)

**Q14.** 서비스 재시작이나 새 인스턴스 배포 시 캐시가 비어있어 초기 요청들이 모두 DB로 몰리는 문제가 발생합니다. **캐시 워밍업(Cache Warming)** 전략을 사용하시는지, 사용한다면 **어떤 데이터를 우선순위로 로드**하시는지 궁금합니다. 또한 배치 작업으로 미리 캐시를 채우는 방식과 **첫 요청 시점에 백그라운드로 로드**하는 방식 중 어떤 것이 더 실용적인지, 그리고 워밍업 중 서비스 가용성에 미치는 영향을 어떻게 최소화하시는지 알고 싶습니다.

## 15. 캐시 직렬화 및 성능 최적화 (Serialization & Performance)

**Q15.** Redis에 객체를 저장할 때 **JSON 직렬화**를 사용 중인데, 대용량 리스트(예: 인기 상품 Top 1000)를 캐싱할 때 직렬화/역직렬화 오버헤드가 성능 병목으로 느껴집니다. **MessagePack**이나 **Protobuf** 같은 바이너리 포맷으로 전환하는 것이 실무에서 일반적인지, 아니면 **Redis Hash 구조**로 분할 저장하는 방식이 더 나은지 궁금합니다. 또한 네트워크 전송량을 줄이기 위한 **압축(Compression)** 기법을 사용하시는지도 궁금합니다.

## 16. 캐시와 비동기 처리의 조합 (Async Processing with Cache)

**Q16.** 주문 생성 후 관련 캐시(인기 상품 랭킹, 사용자별 주문 내역 등)를 무효화해야 하는데, 동기적으로 처리하면 주문 API 응답 시간이 느려집니다. **비동기 이벤트 발행(예: Spring Event, Kafka)**을 통해 캐시 무효화를 처리하는 방식을 고려 중입니다. 하지만 이벤트가 유실되거나 지연될 경우 캐시와 DB 간 불일치가 발생할 수 있어 걱정입니다. 실무에서는 이런 **결과적 일관성(Eventual Consistency)**을 어떻게 관리하시며, 이벤트 재처리나 보상 로직은 어떻게 구현하시는지 궁금합니다.

## 17. 캐시 용량 계획 및 비용 최적화 (Capacity Planning)

**Q17.** 쇼핑몰의 상품 수가 수만 개에 달하고, 각 상품마다 상세 정보, 리뷰 요약, 관련 상품 목록 등을 캐싱하다 보니 Redis 메모리 사용량이 급증하고 있습니다. **캐시할 데이터의 우선순위를 어떻게 결정**하시는지(예: 인기도 기반, 최근 조회 기반), 그리고 **메모리 비용을 절감**하기 위해 어떤 전략을 사용하시는지(예: 데이터 압축, 불필요한 필드 제거, TTL 단축) 궁금합니다. 또한 Redis 인스턴스를 **용도별로 분리**(캐시용, 세션용, 락용)하는 것이 비용 효율적인지도 알고 싶습니다.

## 18. 캐시와 DB 간 데이터 불일치 감지 및 복구 (Data Inconsistency Detection)

**Q18.** Write-Back이나 비동기 캐시 무효화를 사용하다 보면 캐시와 DB 간 데이터 불일치가 발생할 수 있습니다. 실무에서는 **불일치를 어떻게 감지**하시는지(예: 주기적 비교 작업, 이벤트 기반 검증), 그리고 **자동 복구 메커니즘**을 어떻게 구축하시는지 궁금합니다. 특히 주문 금액이나 재고 수량처럼 비즈니스에 치명적인 데이터의 경우, 어떤 수준의 정합성을 보장하시는지 알고 싶습니다.

## 19. 대규모 트래픽에서의 캐시 성능 병목 진단 (Performance Bottleneck Analysis)

**Q19.** 트래픽이 급증할 때 캐시 응답 시간이 느려지거나 타임아웃이 발생하는 경우가 있습니다. **성능 병목을 어떻게 진단**하시는지(예: Redis Slowlog 분석, 네트워크 지연 측정, 직렬화 오버헤드 분석), 그리고 **즉시 적용 가능한 최적화 기법**이 무엇인지 궁금합니다. 또한 캐시 미스율이 높아질 때 DB 부하를 완화하기 위한 **서킷 브레이커나 Rate Limiting** 전략도 알고 싶습니다.

## 20. 캐시를 활용한 비즈니스 로직 최적화 (Business Logic with Cache)

**Q20.** 재고 예약이나 선착순 쿠폰 발급 같은 비즈니스 로직을 캐시를 활용해 구현할 때, **원자성과 정합성을 어떻게 보장**하시는지 궁금합니다. 예를 들어 Redis의 `INCR`, `DECR` 같은 Atomic 연산만으로 충분한지, 아니면 분산 락과 함께 사용해야 하는지, 그리고 **실패 시 롤백 메커니즘**은 어떻게 처리하시는지 알고 싶습니다.

## 21. 마이크로서비스 환경에서의 캐시 아키텍처 (Cache Architecture in MSA)

**Q21.** 마이크로서비스 아키텍처에서 각 서비스가 독립적인 캐시를 가지면 데이터 중복이 발생하고, 공유 캐시를 사용하면 서비스 간 결합도가 높아집니다. **캐시 소유권(Cache Ownership)**을 어떻게 결정하시는지, 그리고 **서비스별 캐시 전략**과 **공유 캐시 전략**을 어떤 기준으로 선택하시는지 궁금합니다. 또한 서비스 간 데이터 동기화는 어떻게 처리하시는지도 알고 싶습니다.

## 22. 복잡한 캐시 무효화 시나리오 처리 (Complex Cache Invalidation)

**Q22.** 상품 정보가 업데이트되면 관련된 수십 개의 캐시(카테고리별 목록, 검색 결과, 추천 상품, 인기 랭킹 등)를 무효화해야 합니다. **의존성 체인이나 순환 참조**가 있는 경우 어떻게 처리하시는지, 그리고 **부분 무효화(Partial Invalidation)**와 **전체 무효화(Full Invalidation)** 중 어떤 전략을 선택하시는지 궁금합니다. 또한 무효화 실패 시 재시도나 보상 로직은 어떻게 구현하시는지도 알고 싶습니다.

## 23. Redis 고급 기능 활용 전략 (Advanced Redis Features)

**Q23.** Redis의 **Stream**, **Pub/Sub**, **Lua Script** 같은 고급 기능을 실무에서 어떤 시나리오에 활용하시는지 궁금합니다. 예를 들어 Stream은 이벤트 로그나 메시지 큐로, Lua Script는 원자적 연산으로 사용하는지, 그리고 이런 기능들이 **캐시 전략에 어떤 영향을 미치는지** 알고 싶습니다. 또한 **Redis Modules**(예: RediSearch, RedisGraph)를 도입하는 기준도 궁금합니다.

## 24. 캐시 전략의 ROI 측정 및 비즈니스 임팩트 (Cache ROI & Business Impact)

**Q24.** 캐시 도입으로 인한 **성능 개선 효과를 정량적으로 측정**하는 방법이 궁금합니다. DB 부하 감소율, 응답 시간 개선, 서버 리소스 절감 등을 어떻게 수치화하시는지, 그리고 **비즈니스 임팩트**(예: 전환율 향상, 이탈률 감소)와 연결하는 방법도 알고 싶습니다. 또한 캐시 투자 대비 효과를 평가하는 **ROI 계산 방식**도 궁금합니다.

## 25. 장애 상황에서의 캐시 복구 및 데이터 복구 (Cache Recovery & Data Recovery)

**Q25.** Redis 장애나 데이터 손실 시 **복구 전략**이 궁금합니다. RDB/AOF 백업을 활용한 복구 프로세스, **캐시 데이터 재구축** 방법, 그리고 장애 중 서비스 가용성을 어떻게 유지하시는지 알고 싶습니다. 또한 **부분 장애**(예: 특정 키만 손실) 상황에서의 복구 전략과, **캐시 미스율 급증 시 DB 보호** 방법도 궁금합니다.

## 26. 캐시 데이터의 보안 및 접근 제어 (Cache Security & Access Control)

**Q26.** Redis에 저장되는 데이터 중 **개인정보나 민감 정보**를 어떻게 관리하시는지 궁금합니다. 암호화 저장, 접근 제어, 감사 로그 등의 보안 조치를 어떻게 적용하시는지, 그리고 **다중 테넌트 환경**에서 데이터 격리는 어떻게 보장하시는지 알고 싶습니다. 또한 캐시 키를 통한 **정보 유출 방지** 전략도 궁금합니다.

## 27. 실시간 데이터 처리와 캐시의 통합 (Real-time Data & Cache Integration)

**Q27.** 주문 생성, 재고 변경 같은 **실시간 이벤트가 발생할 때 캐시를 어떻게 동기화**하시는지 궁금합니다. CDC(Change Data Capture)나 이벤트 소싱 패턴을 활용하시는지, 그리고 **실시간성과 성능 사이의 트레이드오프**를 어떻게 관리하시는지 알고 싶습니다. 또한 **스트리밍 데이터**를 캐시에 반영하는 패턴도 궁금합니다.

## 28. 캐시 적용 기준 및 우선순위 결정 (Cache Application Criteria)

**Q28.** 어떤 데이터나 API에 캐시를 적용해야 하는지 판단하는 **명확한 기준**이 궁금합니다. 조회 빈도, 데이터 변경 주기, 쿼리 비용 등 여러 요소를 어떻게 종합적으로 평가하시는지, 그리고 **캐시를 적용하지 말아야 하는 경우**는 무엇인지 알고 싶습니다. 또한 캐시 도입 전후의 **성능 측정 방법**과 **ROI 계산 기준**도 궁금합니다.

## 29. 캐시 적용하지 말아야 하는 경우 (When NOT to Cache)

**Q29.** 모든 데이터를 캐싱하면 오히려 성능이 저하되거나 복잡도만 증가할 수 있습니다. **캐시를 적용하지 말아야 하는 데이터나 시나리오**는 무엇인지, 그리고 캐시를 적용했을 때 **오히려 손해가 되는 경우**를 어떻게 판단하시는지 궁금합니다. 또한 **과도한 캐싱으로 인한 문제점**과 이를 방지하는 방법도 알고 싶습니다.

## 30. 단일 지점 장애(SPOF)와 Redis 고가용성 (Single Point of Failure)

**Q30.** Redis가 단일 지점 장애(Single Point of Failure)가 될 수 있다는 점이 우려됩니다. **Redis 장애가 서비스 전체에 미치는 영향**을 어떻게 최소화하시는지, 그리고 **Redis Cluster나 Sentinel 구성 없이도 SPOF를 완화**할 수 있는 방법이 있는지 궁금합니다. 또한 Redis 장애 시 **점진적 성능 저하(Graceful Degradation)** 전략도 알고 싶습니다.

## 31. 분산 락의 단일 지점 장애 대응 (Distributed Lock SPOF)

**Q31.** 분산 락을 관리하는 Redis가 장애가 나면 모든 동시성 제어가 실패할 수 있습니다. **분산 락의 SPOF를 어떻게 해결**하시는지, Redlock 알고리즘이나 **다중 Redis 인스턴스 기반 락**을 사용하시는지 궁금합니다. 또한 락 서버 장애 시 **대체 메커니즘**(예: DB 락으로 Fallback)을 어떻게 구현하시는지도 알고 싶습니다.

## 32. 캐시키 구조화 및 네임스페이스 설계 (Cache Key Structure)

**Q32.** 대규모 서비스에서 수만 개의 캐시 키를 관리할 때 **체계적인 키 구조화 전략**이 필요합니다. **계층적 네임스페이스 설계 원칙**(예: `service:domain:type:id`), **키 버전 관리 방법**, 그리고 **키 패턴 기반 일괄 조회/삭제** 전략이 궁금합니다. 또한 **키 길이 최적화**와 **가독성 사이의 트레이드오프**도 알고 싶습니다.

## 33. 캐시키 버전 관리 및 마이그레이션 (Cache Key Versioning)

**Q33.** 스키마 변경이나 데이터 구조 변경 시 **캐시 키 버전 관리**를 어떻게 하시는지 궁금합니다. 버전을 키에 포함시키는 방식(예: `product:v2:123`)과 **기존 버전 캐시와의 호환성 유지** 방법, 그리고 **점진적 마이그레이션 전략**도 알고 싶습니다. 또한 버전이 다른 캐시가 공존할 때 발생하는 문제와 해결 방법도 궁금합니다.

## 34. 캐시 계층 구조 및 의존성 관리 (Cache Hierarchy & Dependencies)

**Q34.** 상품 정보가 업데이트되면 관련된 여러 캐시(목록, 검색 결과, 추천 등)를 무효화해야 합니다. **캐시 간 의존성을 어떻게 관리**하시는지, **의존성 그래프를 기반으로 한 자동 무효화** 메커니즘을 구현하시는지 궁금합니다. 또한 **순환 의존성 문제**를 어떻게 방지하고 해결하시는지도 알고 싶습니다.

## 35. 분산 락 타임아웃 및 데드락 방지 (Distributed Lock Timeout & Deadlock)

**Q35.** 분산 락을 사용할 때 **적절한 타임아웃 시간**을 어떻게 결정하시는지, 그리고 **락을 잡은 프로세스가 비정상 종료**되었을 때 데드락을 방지하는 방법이 궁금합니다. Redisson의 Watchdog 메커니즘 외에 **자체 구현한 락 갱신 로직**을 사용하시는지, 그리고 **분산 환경에서의 데드락 감지 및 해결** 전략도 알고 싶습니다.

## 36. 분산 락 성능 최적화 및 경합 최소화 (Distributed Lock Performance)

**Q36.** 분산 락 경합이 심할 때 **성능 저하**가 발생합니다. **락 경합을 최소화하는 기법**(예: 락 세분화, 비동기 처리)을 어떻게 적용하시는지, 그리고 **락 대기 시간이 길어질 때의 대안 전략**도 궁금합니다. 또한 **락 획득 실패율 모니터링**과 **임계치 기반 알림** 설정 방법도 알고 싶습니다.

## 37. 캐시 히트율 최적화 전략 (Cache Hit Rate Optimization)

**Q37.** 캐시 히트율을 높이기 위한 **구체적인 전략**이 궁금합니다. **TTL 최적화 방법**, **캐시할 데이터 선별 기준**, 그리고 **캐시 워밍업으로 히트율 개선**하는 방법을 어떻게 적용하시는지 알고 싶습니다. 또한 **낮은 히트율의 원인 진단**과 **개선 방안**도 궁금합니다.

## 38. 캐시 메모리 사용량 예측 및 계획 (Cache Memory Planning)

**Q38.** 서비스 규모가 커질수록 캐시 메모리 사용량이 증가합니다. **캐시 메모리 사용량을 어떻게 예측**하시는지, **데이터 크기와 조회 빈도를 기반으로 한 용량 계획** 방법이 궁금합니다. 또한 **메모리 사용량이 임계치에 도달하기 전의 대응 전략**과 **비용 효율적인 메모리 관리** 방법도 알고 싶습니다.

## 39. 분산 락과 DB 락의 선택 기준 (Distributed Lock vs DB Lock)

**Q39.** 동시성 제어를 위해 **분산 락과 DB 락(비관적 락, 낙관적 락) 중 어떤 것을 선택**해야 하는지 판단 기준이 궁금합니다. 각각의 **적용 시나리오**, **성능 특성**, 그리고 **혼용 사용 시 주의사항**도 알고 싶습니다. 또한 **두 방식을 함께 사용**해야 하는 경우와 그 구현 방법도 궁금합니다.

## 40. 캐시 무효화 타이밍 및 전략 (Cache Invalidation Timing)

**Q40.** 데이터 변경 시 **캐시를 언제 무효화**해야 하는지, **즉시 무효화 vs 지연 무효화** 중 어떤 전략을 선택하시는지 궁금합니다. **트랜잭션 커밋 전/후 무효화**의 차이와 영향, 그리고 **배치 작업으로 인한 대량 무효화** 처리 방법도 알고 싶습니다. 또한 **무효화 실패 시 재시도 전략**도 궁금합니다.

## 41. 캐시와 트랜잭션의 일관성 보장 (Cache & Transaction Consistency)

**Q41.** DB 트랜잭션과 캐시 업데이트를 함께 처리할 때 **일관성을 어떻게 보장**하시는지 궁금합니다. **트랜잭션 커밋 후 캐시 업데이트** 방식과 **트랜잭션 롤백 시 캐시 처리** 방법, 그리고 **분산 트랜잭션 환경에서의 캐시 일관성** 유지 전략도 알고 싶습니다. 또한 **2PC와 캐시의 통합** 방법도 궁금합니다.

## 42. 분산 락의 공정성(Fairness) 보장 (Distributed Lock Fairness)

**Q42.** 여러 프로세스가 동시에 락을 요청할 때 **공정한 순서로 락을 할당**하는 방법이 궁금합니다. **FIFO 큐 기반 락**이나 **우선순위 기반 락**을 구현하시는지, 그리고 **특정 프로세스가 계속 락을 못 얻는 기아(Starvation) 문제**를 어떻게 해결하시는지 알고 싶습니다. 또한 **락 대기 시간의 공정성**을 보장하는 방법도 궁금합니다.

## 43. 캐시 데이터 압축 및 최적화 (Cache Data Compression)

**Q43.** 대용량 데이터를 캐싱할 때 **압축 기법을 어떻게 적용**하시는지 궁금합니다. **압축 알고리즘 선택 기준**(gzip, snappy, lz4 등), **압축/해제 오버헤드와 메모리 절감의 트레이드오프**, 그리고 **언제 압축을 사용해야 하는지** 판단 기준도 알고 싶습니다. 또한 **Redis에서의 압축 적용 방법**도 궁금합니다.

## 44. 분산 락의 재진입(Reentrancy) 지원 (Distributed Lock Reentrancy)

**Q44.** 같은 스레드나 프로세스가 **이미 획득한 락을 다시 획득**하려고 할 때(재진입) 어떻게 처리하시는지 궁금합니다. **재진입 카운터를 관리**하는 방법, **중첩된 락 획득 시나리오** 처리, 그리고 **재진입 지원의 장단점**도 알고 싶습니다. Redisson의 `ReentrantLock` 외에 **자체 구현 시 고려사항**도 궁금합니다.

## 45. 캐시 키 기반 권한 및 접근 제어 (Cache Key Access Control)

**Q45.** 사용자별로 접근 가능한 데이터가 다른 경우 **캐시 키에 권한 정보를 어떻게 반영**하시는지 궁금합니다. **사용자 ID를 키에 포함**시키는 방식과 **권한 기반 캐시 무효화** 전략, 그리고 **캐시 키를 통한 정보 유출 방지** 방법도 알고 싶습니다. 또한 **다중 테넌트 환경에서의 키 격리** 전략도 궁금합니다.

## 46. 캐시 스노우볼 효과 및 연쇄 무효화 (Cache Snowball Effect)

**Q46.** 하나의 데이터 변경이 **연쇄적으로 많은 캐시를 무효화**시키는 스노우볼 효과가 발생할 수 있습니다. **이를 어떻게 방지**하시는지, **무효화 범위를 최소화**하는 전략, 그리고 **배치 무효화로 인한 캐시 미스 폭증**을 어떻게 완화하시는지 궁금합니다. 또한 **무효화 우선순위**를 어떻게 결정하시는지도 알고 싶습니다.

## 47. 분산 락의 읽기/쓰기 락 분리 (Read-Write Lock in Distributed Environment)

**Q47.** 읽기 작업은 동시에 여러 개가 가능하지만 쓰기 작업은 배타적으로 처리해야 할 때 **분산 환경에서의 Read-Write Lock**을 어떻게 구현하시는지 궁금합니다. Redisson의 `RReadWriteLock` 사용 경험, **읽기 락과 쓰기 락의 우선순위** 관리, 그리고 **읽기 락이 많을 때 쓰기 락의 기아 문제** 해결 방법도 알고 싶습니다.
