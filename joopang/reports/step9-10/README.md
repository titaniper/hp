# Step 9-10: 동시성 제어 및 트랜잭션 최적화 보고서

본 문서는 `OrderService`와 `CouponService` 등 핵심 비즈니스 로직에서 발견된 동시성 제어 이슈와 트랜잭션 관리의 비효율성을 진단하고, 이를 해결하기 위해 적용한 개선 사항과 향후 계획을 기술합니다.

## 1. 문제 식별 (Problem Identification)

현재 시스템은 단일 인스턴스 환경에서는 정상적으로 동작하는 것처럼 보이지만, **다중 서버 환경(Scale-out)**으로 확장하거나 **주문 요청이 폭주하는 상황**에서는 심각한 데이터 정합성 문제와 성능 저하가 발생할 수 있는 구조적 취약점을 안고 있습니다.

주요 식별된 리스크는 다음과 같습니다.

*   **데이터 정합성 위협**: 동일한 쿠폰을 여러 주문에서 동시에 사용하여 중복 할인을 받는 **Double Spending** 현상이 발생할 수 있습니다.
*   **교착 상태(Deadlock) 위험**: 여러 상품을 한 번에 주문할 때 락 획득 순서가 보장되지 않아, 특정 상황에서 스레드가 서로를 무한히 기다리는 교착 상태에 빠질 수 있습니다.
*   **확장성(Scalability) 제약**: 메모리 기반의 JVM 락(ReentrantLock)을 사용하고 있어, 서버를 증설(Scale-out)할 경우 인스턴스 간 동기화가 불가능해집니다.
*   **성능 병목 구간**: 트랜잭션 내부에서 외부 API 호출(결제 데이터 전송)을 수행하고 있어, 외부 시스템의 지연이 곧 DB 커넥션 고갈로 이어지는 구조입니다.


## 2. 상세 분석 (Deep Dive Analysis)

소스 코드 분석을 통해 트랜잭션 경계와 락킹 전략(Locking Strategy)의 현황을 다음과 같이 진단했습니다.

### 2.1. 포인트 차감 프로세스
*   **현황**: `processPayment` 메서드에서 `userRepository.findByIdForUpdate`를 호출하여 **비관적 락(Pessimistic Lock)**을 사용하고 있습니다.
*   **진단**: 비관적 락 덕분에 유저 잔액에 대한 동시성 제어는 안전하게 이루어지고 있습니다. 하지만 락을 보유한 채로 트랜잭션 마지막 단계에서 외부 시스템(`dataTransmissionService.send`)과 통신하는 것이 문제입니다. 외부 API 응답이 지연될 경우, 해당 유저 레코드에 대한 락(Lock) 점유 시간이 길어져 충전이나 조회 등 다른 서비스 요청까지 블로킹될 위험이 큽니다.

### 2.2. 재고 차감 프로세스
*   **현황**: `reserveStock` 메서드 진입 시 `ProductLockManager`를 통해 JVM 레벨의 락을 걸고, 이후 DB 업데이트 쿼리(`UPDATE ... SET stock = stock - ?`)를 실행합니다.
*   **진단**:
    *   DB 쿼리 자체가 원자적(Atomic)이므로 사실상 JVM 락 없이도 재고 정합성은 보장됩니다. 불필요한 JVM 락이 오히려 성능을 저해하고 있습니다.
    *   더 큰 문제는 다중 상품 주문 시 락 획득 순서(Ordering)를 강제하지 않는다는 점입니다. `[상품A, 상품B]` 주문과 `[상품B, 상품A]` 주문이 경합할 경우 상호 간에 락을 기다리는 **데드락(Deadlock)** 발생 가능성이 존재합니다.

### 2.3. 쿠폰 사용 및 검증
*   **현황**: 결제 과정에서 쿠폰 상태를 확인할 때 단순 조회(`findByIdOrNull`) 후 애플리케이션 로직으로 검증하고 있습니다.
*   **진단**: 조회 시점에 아무런 락(Lock)이 걸려있지 않습니다. 따라서 사용자 A가 동시에 두 개의 주문 요청을 보내면, 두 트랜잭션 모두 '사용 가능(AVAILABLE)' 상태의 쿠폰을 읽게 됩니다. 결과적으로 하나의 쿠폰으로 두 번 할인을 적용받는 치명적인 결함이 발생합니다.

### 2.4. 트랜잭션 격리 수준
*   MySQL의 기본 격리 수준인 `REPEATABLE READ`를 사용 중입니다. 하지만 `SELECT ... FOR UPDATE`와 같은 명시적인 락이 없는 일반 조회에서는 동시 수정에 대한 방어가 불가능하므로, 격리 수준 변경보다는 올바른 락킹 전략 도입이 시급한 상황입니다.


## 3. 해결 방안 (Solution Strategy)

위에서 분석한 문제점들을 해결하기 위해 다음과 같이 코드를 개선했습니다.

### 3.1. 쿠폰 동시성 제어 강화
*   **조치**: `CouponRepository`에 비관적 락(`@Lock(LockModeType.PESSIMISTIC_WRITE)`)을 적용한 `findByIdForUpdate` 메서드를 추가했습니다.
*   **효과**: 이제 쿠폰을 조회하는 시점에 DB 행 락(Row Lock)을 획득합니다. 다른 트랜잭션이 동시에 같은 쿠폰에 접근하려 하면 대기하게 되므로, 중복 사용(Double Spending) 문제를 원천적으로 차단했습니다.

### 3.2. 트랜잭션 범위 최적화 (외부 I/O 분리)
*   **조치**: `OrderService.processPayment` 내에 존재하던 외부 데이터 전송 로직을 `TransactionSynchronizationManager.registerSynchronization(afterCommit)`을 활용하여 **트랜잭션 커밋 이후**에 실행되도록 리팩토링했습니다.
*   **효과**: 결제 데이터가 DB에 안전하게 반영된 후 비동기적으로 외부 통신을 수행합니다. 외부 시스템에 장애가 발생하더라도 우리 시스템의 DB 커넥션이나 락을 불필요하게 점유하지 않아 전체적인 시스템 안정성을 확보했습니다.

### 3.3. 재고 관리 개선 (진행 중)
*   우선적으로 리스크가 큰 쿠폰 및 결제 로직을 안정화했습니다. 재고 차감 로직의 데드락 이슈는 추후 구조 개선을 통해 해결할 예정입니다.


## 4. 향후 계획 (Next Steps)

### 4.1. Redis 분산 락(Distributed Lock) 도입
현재 적용한 비관적 락은 데이터 정합성 측면에서는 확실하지만, 트래픽이 급증할 경우 DB 커넥션 고갈을 유발할 수 있는 한계가 있습니다.
이에 따라 다음 단계에서는 **Redis 기반의 분산 락**을 도입할 예정입니다.
*   **목표**: 락 관리에 대한 부하를 DB에서 Redis로 이관하여 DB 리소스를 보호.
*   **기대 효과**: Redisson 라이브러리 등을 활용하여 스핀 락(Spin Lock) 대신 Pub/Sub 방식으로 효율적인 대기열을 구현하고, 다중 서버 환경에서도 일관된 동시성 제어를 보장합니다.

### 4.2. 레거시 코드 정리 (JVM 락 제거)
분산 락 도입과 함께, 현재 코드 곳곳에 남아있는 `ReentrantLock` 기반의 로컬 락 코드를 전면 제거할 계획입니다.
*   **이유**: 분산 환경에서 실효성이 없을 뿐만 아니라 코드 복잡도만 높이고 있어 유지보수에 방해가 됩니다.
*   **계획**: `ProductLockManager` 등을 삭제하고, 동시성 제어는 DB 쿼리의 원자성이나 분산 락으로 명확하게 대체하여 코드 가독성을 높이겠습니다.
