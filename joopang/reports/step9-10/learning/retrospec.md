- DB 설계 개선 및 구현
  - 전체적인 엔티티에 간접 참조 방식을 사용해 느슨한 매핑을 규칙으로 가져가신 것 같습니다.
    - 지금 연관관계가 있는 엔티티를 한꺼번에 조회하는 요구사항이 많지는 않지만, 그럼에도 몇몇 엔티티 관계는 생각해볼 필요가 있습니다.
    - 예를 들어 '주문과 주문상품 목록을 함께 조회'하는 기능이 추가된다면 직접참조와 FETCH JOIN으로 최적화할지, 그럼에도 간접참조로 느슨한 관계를 유지할지는 잘 판단해보시면 좋겠습니다. JOIN에만 사용될 Projection을 선언하는 방법도 있습니다.
  - 전반적으로 Repository 구현에 EntityManager가 직접 사용되었습니다.
    - Spring Data JPA의 서포트를 꼭 받아야 하는건 아니지만, 유지보수 측면에서의 장단점이 있으니 고민해보시기 바랍니다.
      - 변경해야 한다는 것은 아닙니다😅 구현은 모두 올바르게 되어 있습니다! 
    - 흔하게 사용되는 Spring Data JPA 기능 중에서는.. 메서드명 기반 쿼리, Pageable을 통한 페이징, Auditing 등이 있습니다.
    - merge, persist 등 라이프사이클 제어 측면에서 추상화도 많이 되어있습니다. EntityManager로 직접 제어하는 것이 장점이라고 보는 시각도 있겠지만, 그만큼 라이프사이클에 대한 정확한 제어가 필요합니다.
  - ReentrantLock 기반으로 동시성 문제를 해결하고 있습니다.
    - 애플리케이션을 하나만 실행하는 환경이라면 유효한 방식입니다. 트랜잭션의 afterCompletion hook을 잘 활용해 주셨습니다.
    - 보통 실무에서는 이중화를 위해 2개 이상의 서버에서 애플리케이션을 실행하므로, DB 메커니즘을 활용한 동시성 제어도 해보시기 바랍니다.
  - 모든 테스트가 잘 동작합니다. 테스트 품질이 잘 유지되고 있습니다👍
    - IntegrationTestSupport에서 통합테스트를 위한 설정들을 추상화하고 있는 점도 좋습니다. 통합테스트 간 일관된 환경을 구성하기 용이합니다.
- DB 최적화
  - reports 디렉터리 내에서 어떤 문서들이 이번 과제에 해당하는지 명시해주시면 더 좋을 것 같습니다. PR 변경사항에는 디렉터리 전체가 포함되어 있습니다.
  - order_index_test-plan.md
    - 인덱스 2개를 추가했는데, 결과적으로 사용된 인덱스는 idx_orders_status_paid_at_desc로 보입니다.
    - status 조건과 paid_at 정렬이 있는 쿼리일 것 같습니다. OrderRepository에서 그러한 조건으로 실행하는 쿼리는 없어 보이는데, 어떤 기능에 사용되는 쿼리일까요?
  - 전반적인 보고서의 구조와 가독성은 개선이 필요합니다.
    - index-optimization.md에서는 '주요 경로'로 어떤 메서드인지를 보이고 있지만, 어떤 쿼리인지도 명시하는 편이 좋습니다. 메서드명 기반으로 쿼리를 생성하지 않는 경우도 있습니다(특히 지금은 EntityManager에서 쿼리를 직접 생성하네요).
- 고생 많으셨습니다.