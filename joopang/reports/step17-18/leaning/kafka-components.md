# 카프카 구성요소 정리

## 구성요소 관계 시각화
```
┌──────────┐       ┌───────────────┐       ┌──────────┐
│ Producer ├──────▶│   Topic &     │◀──────┤ Consumer │
└──────────┘ send  │  Partitions   │ fetch └──────────┘
        ▲          │  (리더/팔로워)│          ▲
        │          └───────────────┘          │
        │ metadata        ▲                   │ offsets
        │                 │                   │
        │            ┌────┴────┐               │
        └────────────┤ Broker  ├───────────────┘
                     │ (Cluster│
                     │ Controller)
                     └─────────┘
```

## Broker
- 카프카 클러스터를 구성하는 서버 인스턴스다.
- 각 브로커는 특정 토픽 파티션의 리더/팔로워 역할을 담당하며, 리더 파티션에 대한 읽기·쓰기를 처리한다.
- 메타데이터(토픽, 파티션, ISR 등)를 주키퍼 또는 KRaft 컨트롤러와 동기화해 클러스터 전체 상태를 일관성 있게 유지한다.
- 브로커는 로그 세그먼트를 디스크에 저장하고, 복제·압축·보존 정책을 적용한다.

## Topic
- 메시지를 논리적으로 구분하기 위한 이름 공간으로, 애플리케이션 별 데이터 스트림을 독립적으로 관리할 수 있게 한다.
- 토픽은 하나 이상의 파티션으로 구성되어 병렬 처리와 확장성을 제공한다.
- 동일 토픽 내 메시지는 키, 파티션 전략에 따라 순서를 보장하거나 부하를 분산할 수 있다.

## Partition
- 토픽의 실제 저장 단위이자 메시지 순서가 유지되는 로그 구조다.
- 각 파티션은 append-only 로그로, 오프셋(offset)이라는 단조 증가하는 인덱스로 메시지를 식별한다.
- 파티션은 복제 팩터(replication factor)에 따라 여러 브로커에 복제되어 가용성과 장애 복구 능력을 확보한다.
- 리더 파티션이 클라이언트 요청을 처리하고, 팔로워는 리더를 따라가며 ISR(In-Sync Replica) 집합을 형성한다.

## Producer
- 애플리케이션에서 카프카로 데이터를 전송하는 클라이언트다.
- 토픽·파티션 선택 로직(라운드 로빈, 키 해싱, 커스텀 파티셔너)을 통해 메시지를 분배한다.
- 배치 및 압축 전략을 활용해 네트워크 사용량과 처리량을 최적화하며, acks 설정으로 내구성과 지연 간 트레이드오프를 제어한다.
- idempotence, 트랜잭션 기능을 사용하면 중복 없는 전송과 다중 토픽/파티션 간 원자성을 확보할 수 있다.

## Consumer
- 토픽 파티션에서 메시지를 읽어 애플리케이션 로직으로 전달한다.
- 컨슈머 그룹 단위로 파티션을 할당받아 병렬 처리하면서, 한 파티션은 항상 그룹 내 한 컨슈머에게만 할당되어 순서를 보장한다.
- 오프셋 커밋 전략(자동/수동 커밋)을 통해 재처리, 중복 처리 정책을 조정한다.
- 리밸런싱, 컨슈머 랙 모니터링 등을 통해 장애 대응과 처리 지연을 관리한다.

## 기타 핵심 개념
- **Controller**: 특정 브로커가 선출되어 파티션 리더 선출, 브로커 상태 추적 등 클러스터 메타데이터 관리를 담당한다.
- **Replication**: 복제 팩터에 따라 동일 파티션 로그를 여러 브로커에 저장해 장애 시 빠르게 리더를 대체한다.
- **Retention**: 토픽별 보존 정책(시간/용량 기반)으로 오래된 데이터를 삭제하거나 압축(compaction)해 스토리지를 관리한다.
- **Schema Registry**: (선택) Avro, Protobuf 스키마를 중앙에서 관리해 프로듀서·컨슈머 간 스키마 호환성을 보장한다.
