# 카프카 개요와 특성

## 왜 빠른가?
- **디스크 기반 순차 쓰기**: 메모리가 아니라 디스크에 append-only 로그로 저장하지만 순차 I/O 덕분에 캐시 친화적이며, 페이지 캐시 활용으로 실질적으로 메모리 쓰기와 유사한 속도를 보인다.
- **배치와 압축**: 프로듀서가 여러 메시지를 배치로 묶고 압축해 네트워크 왕복 횟수를 줄인다.
- **제로-카피 전송**: 브로커는 파일 시스템 캐시에서 소켓으로 데이터를 직접 전송(sendfile)해 CPU 오버헤드를 최소화한다.
- **수평 확장**: 토픽을 파티션으로 나누고 파티션을 여러 브로커에 분산함으로써 병렬 처리량을 높인다.

## 특징
- **분산 로그 저장소**: 이벤트 스트림 데이터를 길게 보존하며, 여러 컨슈머 그룹이 독립적으로 읽는다.
- **백프레셔 내성**: 컨슈머가 느려도 브로커에 데이터가 남아 있어 재처리와 리플레이가 가능하다.
- **강력한 복제 모델**: ISR 기반 복제로 브로커 장애 시 빠르게 리더를 교체하고 내구성을 제공한다.
- **플랫폼 생태계**: Connect, Streams, ksqlDB 등과 결합해 데이터 파이프라인을 구성할 수 있다.

## 장점
1. **고성능/저지연**: 대규모 데이터 처리에도 안정적인 throughput.
2. **확장 용이성**: 파티션/브로커를 추가해 수평 확장.
3. **내구성과 재처리**: 로그 보존과 오프셋 관리로 과거 데이터를 쉽게 재처리.
4. **다양한 클라이언트 지원**: 언어별 클라이언트, 커넥터, 스트림 처리 프레임워크.

## 단점/주의사항
1. **운영 복잡도**: 브로커, 주키퍼/KRaft, 모니터링, 스토리지 등 인프라 관리 부담.
2. **데이터 모델 제약**: 파티션 키 설계가 까다로우며, 크로스 파티션 트랜잭션이 제한적.
3. **지연 기준**: 밀리초 단위 지연은 가능하지만 하위 ms 실시간 시스템에는 부적합할 수 있다.
4. **데이터 삭제 지연**: 보존 기간이 길면 디스크 관리가 어렵고, compaction은 CPU를 사용한다.

## 사용 시 고려
- 워크로드 특성(메시지 크기, 처리 지연 허용치)을 파악해 브로커 수와 파티션 수를 계획한다.
- 토픽별 SLA에 따라 보존 정책과 복제 팩터를 조정해 비용과 신뢰도 균형을 맞춘다.
- Schema Registry, ACL, 정합성 검증 프로세스를 포함한 운영 체계를 수립한다.
