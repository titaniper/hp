# Transaction Outbox Pattern

## 목적
- OLTP 데이터베이스에서 상태 변경과 이벤트 발행을 동일 트랜잭션으로 처리해 데이터 정합성을 확보한다.
- 애플리케이션이 DB 업데이트 후 카프카로 이벤트를 보낼 때, 중간 실패로 인한 이중 쓰기 문제를 방지한다.

## 동작 흐름
1. 애플리케이션이 비즈니스 테이블과 `outbox` 테이블을 같은 트랜잭션으로 업데이트한다.
2. 트랜잭션 커밋 후, 별도 프로세스(폴러 또는 Debezium 같은 CDC)가 `outbox` 레코드를 읽어 카프카 토픽으로 발행한다.
3. 성공적으로 전송된 이벤트는 `outbox`에서 삭제하거나 상태를 갱신한다.

## 구현 요소
- **Outbox 테이블**: `id`, `aggregate_type`, `aggregate_id`, `payload`, `status`, `created_at` 등 메타데이터를 가진다.
- **CDC/폴러**: Debezium, Kafka Connect JDBC Source, 혹은 커스텀 배치 잡이 outbox를 읽어 이벤트로 변환.
- **Idempotence**: outbox `id`를 메시지 키로 사용해 중복 전송을 허용하더라도 컨슈머가 dedupe할 수 있도록 한다.
- **정책**: outbox 테이블을 주기적으로 정리하고, DLQ와 연동해 실패 이벤트를 추적한다.

## 장점
- 데이터베이스 트랜잭션에 이벤트 발행을 포함시켜 **정확히 한 번** 발생을 보장한다.
- 애플리케이션 코드가 복잡한 멱등 로직 없이도 안정적으로 이벤트를 방출한다.
- CDC를 활용하면 기존 시스템에도 쉽게 적용 가능하다.

## 단점/주의사항
- Outbox 테이블이 커질 수 있으므로 파티셔닝, TTL, 보관 정책이 필요하다.
- CDC 지연 또는 폴링 주기에 따라 이벤트 전달 지연이 발생한다.
- 멀티-리전/멀티-DB 환경에서는 트랜잭션 경계가 달라지므로 설계가 복잡해질 수 있다.

## 카프카 연계 팁
- Kafka Connect + Debezium Outbox SMT를 사용하면 outbox 테이블 스키마를 이벤트 포맷으로 직접 변환할 수 있다.
- 컨슈머는 outbox 이벤트를 처리할 때 원본 데이터베이스의 상태와 일치함을 가정할 수 있으므로, 추가 검증 비용이 줄어든다.
- Outbox 이벤트를 멱등성 있게 처리하기 위해 카프카 키를 `aggregate_id`와 `id` 조합으로 설정한다.
