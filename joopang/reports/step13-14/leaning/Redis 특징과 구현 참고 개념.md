# Redis 특징과 구현 시 참고 개념

## Redis의 주요 특징
- **인메모리 기반**: 모든 데이터가 RAM에 상주하므로 초당 수십만 QPS, 하지만 메모리 비용과 eviction 정책 설계가 필수.
- **단일 쓰레드 이벤트 루프**: 명령 실행이 원자적이며 컨텍스트 전환 비용이 없다. 대신 느린 명령 하나가 전체 처리량을 막는다.
- **다양한 자료구조**: 문자열부터 스트림까지 고수준 추상화를 제공하여 애플리케이션 복잡도를 줄인다.
- **쉬운 복제/클러스터링**: 마스터-레플리카 구성과 샤딩 클러스터를 모두 지원, 수평 확장이 비교적 단순.
- **스크립팅/모듈**: Lua 스크립트로 원자적 연산을 커스터마이즈할 수 있고, 모듈로 새로운 자료구조(예: RedisJSON)를 추가 가능.

## 설계 시 고려할 추가 개념
### 1. Persistence 전략
| 방식 | 설명 | 장단점 |
| --- | --- | --- |
| RDB (스냅샷) | 일정 주기로 메모리 덤프 | 빠른 복구, I/O 스파이크 발생 가능 |
| AOF | 명령 로그를 Append | 더 작은 RPO, 파일 커짐 → 주기적 리라이트 필요 |
| 혼합 (6.0+) | RDB+증분AOF 결합 | 빠른 재시작 + 낮은 손실, 설정 복잡 |
- 운영에서는 `AOF + 매일 RDB 백업` 패턴이 일반적.

### 2. 복제 & 고가용성
- **레플리카 지연**: 네트워크/디스크에 따라 수백 ms 지연. 강한 일관성이 필요하면 쓰기 후 읽기 대상은 마스터로 고정하거나 `WAIT` 명령으로 동기화 레플리카 수를 보장.
- **Sentinel**: 마스터 장애 감지 및 자동 페일오버. 최소 3개 이상의 Sentinel 프로세스를 독립 호스트에 배치.
- **Cluster**: 16384 해시 슬롯으로 키를 분배. 키스페이스 조인 필요 시 `HASH TAG` 패턴(`key{userId}:field`).

### 3. 네트워크/프로토콜 최적화
- **Pipeline**: 다중 요청을 묶어 RTT를 줄임. 대량 쓰기 시 필수.
- **Client-side caching**: Redis 6 이후 `CLIENT TRACKING`으로 변경 알림을 받아 캐시 일관성을 유지.
- **I/O Thread**: 6.0+ 버전에서 네트워크 I/O만 멀티스레드화. CPU 코어 수에 맞춰 `io-threads`를 조정.

### 4. 메모리 및 데이터 관리
- **maxmemory 정책**: `volatile-lru`, `allkeys-lfu` 등. 서비스별로 다르게 운영하려면 인스턴스를 분리.
- **Keyspace Events**: 키 만료/생성을 Pub/Sub으로 수신하여 캐시 동기화. 이벤트 종류별로 선택적 활성화.
- **Modules**: RedisBloom, RedisSearch 등 고급 기능을 별도 서비스 없이 도입 가능. 단, 업그레이드 및 호환성 체크 필요.

### 5. 보안/운영 가이드
- 인증(`requirepass`) 및 ACL을 사용하고, 외부 노출 시 TLS/Tunneling 적용.
- 모니터링 지표: `used_memory`, `connected_clients`, `evicted_keys`, `rejected_connections`, `latency spikes`. 장애 재현을 위해 `LATENCY DOCTOR` 활용.
- 백업 파일은 압축/암호화하여 저장하고, 재해 복구 훈련 시 실제로 복구 절차를 검증.

## 구현 시 체크리스트
1. 예상 피크 메모리 + 30% 버퍼가 확보되어 있는가?
2. 키 네임스페이스를 모듈/도메인 단위로 분리했는가?
3. 장애 시 복구 목표(RTO/RPO)에 맞는 Persistence 전략을 설정했는가?
4. 느린 명령(예: `ZRANGE` 대용량) 감지 알람이 존재하는가?
5. 샤딩/클러스터 환경에서 멱등성 보장 로직이 준비되어 있는가?

## 참고 자료
- Redis 엔터프라이즈 아키텍처 가이드
- antirez 블로그: 이벤트 루프와 I/O thread 디자인
- `redis.io/docs` 의 Data Types, Develop, Operate 섹션
