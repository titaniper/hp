# Redis 기반 선착순 쿠폰 발급 계획 리포트 (실 구현 대응)

1. **리포트 개요**
   - `/src/main/kotlin/io/joopang/services/coupon/presentation/CouponController.kt`와 `/src/main/kotlin/io/joopang/services/coupon/application/CouponService.kt`를 기반으로, 기존 레디슨 락 + RDB 직발급 방식을 Redis 큐/스트림 아키텍처로 이행하기 위한 실제 구현 계획을 다룬다.

2. **현황 및 문제**
   - `CouponController.issueCoupon`은 즉시 `CouponService.issueCoupon`을 호출해 쿠폰을 발급하고 남은 수량을 응답한다.
   - 서비스 레이어는 `@DistributedLock`으로 템플릿 단위 임계영역을 만들고, 사용자의 전체 쿠폰 목록을 조회해 중복 발급을 막은 뒤 `couponTemplateRepository.incrementIssuedQuantity`를 호출한다.
   - 락 경합 시 TPS가 급락하며, 사용자별 전체 쿠폰 조회와 RDB 업데이트가 즉시성 응답을 가로막는다.

3. **기존 쿠폰 발급 흐름(레이어)**
   1. `CouponController` (Presentation): `POST /coupons/{templateId}/issue` 요청을 받아 `CouponService.IssueCouponCommand`를 구성한 뒤, 단일 진입점인 `CouponIssueFacade.requestIssue`를 호출한다.  
      - 코드: `src/main/kotlin/io/joopang/services/coupon/presentation/CouponController.kt:24-37`
   2. `CouponIssueFacade` (Application): `UserRepository`/`CouponTemplateRepository`로 존재 검증을 수행하고 템플릿 잔여 수량·기간을 점검한다. `coupon.issue.async-enabled` 플래그에 따라 즉시 `couponService.issueCoupon`을 호출하거나 `CouponIssueCoordinator.enqueue`로 비동기 대기열에 적재한다.  
      - 코드: `src/main/kotlin/io/joopang/services/coupon/application/issue/CouponIssueFacade.kt:21-45`
   3. `CouponService` (Domain): 동기 발급 시에만 실행되며, `@DistributedLock`으로 템플릿별 임계구역을 보호하면서 사용자 중복 발급 검사, 템플릿 잔량 차감, 사용자 쿠폰 엔티티 생성/저장을 담당한다. 사용자 쿠폰 조회 API(`getUserCoupons`) 역시 동일 서비스에서 노출된다.  
      - 코드: `src/main/kotlin/io/joopang/services/coupon/application/CouponService.kt:25-107`
   4. Repository (Infra): `UserRepository`, `CouponTemplateRepository`, `CouponRepository`가 각 도메인 엔티티의 영속화를 담당한다. Facade는 검증용 조회까지만 수행하고, 실제 발급·저장은 `CouponService`에서 일어난다.  
      - 코드: `src/main/kotlin/io/joopang/services/user/infrastructure/UserRepository.kt`, `src/main/kotlin/io/joopang/services/coupon/infrastructure/*`

   이 구조 덕분에 프레젠테이션 계층은 HTTP 세부사항에 집중하고, Facade는 유스케이스 전반의 검증·분기, 서비스는 도메인 규칙과 영속성 일관성에 집중한다. Redis 큐 기반으로 전환할 때도 이 책임 분리를 유지하되 Facade가 동기/비동기 흐름을 제어하고, 서비스는 폴백·확정 저장 로직으로 좁히는 것이 목표다.

4. **목표**
   - API 레이어에서는 요청을 빠르게 큐에 적재하고, Redis 기반 발급 워커가 비동기적으로 순서를 확정한 뒤 RDB에 확정 저장하도록 역할을 분리한다.
   - Lua 스크립트 없이도 유지보수 가능한 구조(스트림, Consumer Group, 키 단위 파티셔닝)를 적용해 복잡한 스크립트 관리 비용을 제거한다.
   - 사용자 응답 DTO(`CouponIssueResponse`)에 큐 등록 결과(대기 번호, 예상 지연 등)를 포함시켜 클라이언트 UX를 개선한다.

5. **Redis 설계 (Lua 미사용)**
   - **핵심 키/구성요소**
     | 키 | 타입 | 설명 |
     | --- | --- | --- |
     | `coupon:request-stream` | Stream | API가 발급 요청 이벤트를 `XADD`로 밀어 넣는다 (`fields: templateId, userId, requestedAt`).
     | `coupon:issued:{templateId}` | Set | 이미 발급된 사용자 ID 집합. 워커가 `SADD`로 관리해 중복 발급을 막는다.
     | `coupon:stock:{templateId}` | String | 초기 재고를 `SET` 후 워커가 `DECR`로 관리한다. 음수가 되면 실패 이벤트를 기록한다.
     | `coupon:queue-position:{templateId}` | Sorted Set | API에서 `ZADD`로 대기열 순위를 기록해 사용자에게 순번과 예상 지연을 계산해준다.
     | `coupon:issue-stream` | Stream | 워커가 성공/실패 결과를 기록하고, 별도 컨슈머가 RDB `couponRepository.save`를 수행한다.
   - **처리 흐름**
     1. Controller → Service: 기존 `CouponService.issueCoupon` 내부에서 락/DB 처리 대신 `CouponIssueCoordinator.enqueue()` 호출로 전환한다. 이 메서드는 `ZADD queue-position`과 `XADD request-stream`을 `RedisTemplate` 파이프라인으로 실행한다.  
        - 코드: `src/main/kotlin/io/joopang/services/coupon/presentation/CouponController.kt:24-36`, `.../coupon/application/issue/CouponIssueFacade.kt:34-45`, `.../coupon/application/issue/CouponIssueCoordinator.kt:34-71`
     2. 워커(코루틴/스케줄러): `XREADGROUP`으로 `coupon:request-stream`을 읽어 templateId별로 샤딩된 단일 쓰레드 워커를 구성한다. 단일 워커만 해당 templateId를 처리하므로 Lua 없이도 순서/원자성 확보가 가능하다.  
        - 코드(예정): `src/main/kotlin/io/joopang/services/coupon/application/issue/*Worker.kt` (추가 예정)
     3. 워커 로직: `SADD issued:{templateId} userId` 성공 여부로 중복 체크 → `DECR coupon:stock:{templateId}` 결과가 0 이상이면 성공으로 간주하고 `coupon:issue-stream`에 이벤트 작성. 실패 시 queue-position ZSET에서 사용자 제거, 응답 스트림에 실패 이벤트 작성.  
        - 코드(예정): 동일 워커 구현 내부
     4. 결과 컨슈머: `coupon:issue-stream`을 읽어 `couponRepository.save` 및 `couponTemplateRepository.incrementIssuedQuantity`를 수행하고, 완료 후 스트림 ack 처리.  
        - 코드(예정): `src/main/kotlin/io/joopang/services/coupon/application/issue/CouponIssueResultListener.kt` (추가 예정)
     5. API 응답: `CouponIssueResponse`에 `queueRank`, `estimatedWaitMillis` 필드를 추가하고, queue-position ZSET에서 현재 순위를 계산해 반환한다.  
        - 코드: `src/main/kotlin/io/joopang/services/coupon/presentation/CouponController.kt:47-80`, `.../coupon/application/issue/CouponIssueCoordinator.kt:57-71`

6. **서비스/컨트롤러 수정 계획**
   - `CouponService.issueCoupon`
     - 기존 `@DistributedLock`은 초기 롤아웃 동안 유지해 Redis 경로 장애 시 즉시형 처리로 폴백할 수 있게 한다. 추후 Redis 경로가 안정화되면 제거 여부를 재평가한다.
     - 사용자/템플릿 존재 여부만 즉시 검증 후 `CouponIssueCoordinator.enqueue` 호출로 흐름을 위임하고, 동기 발급 로직은 폴백 경로로 남겨둔다.
     - 반환 타입을 `IssueCouponOutput` → `IssueCouponAsyncOutput`(대기 정보, 추적용 requestId 포함)로 변경하고 Controller 변환 함수를 갱신한다.
   - `CouponController`
     - `CouponIssueResponse` DTO에 `queueRank`, `estimatedWaitMillis`, `requestId` 필드 추가.
     - 사용자 쿠폰 조회 API는 기존 로직을 유지하되, Redis 워커가 확정 저장한 데이터만 조회하게 된다.
   - 신규 컴포넌트
     - `CouponIssueCoordinator`: RedisTemplate, Stream listener container 등을 조합해 큐잉과 워커 소비를 담당한다. 서비스 레이어가 Redis 처리 세부사항에 직접 의존하지 않도록 경계를 만들며, 템플릿별 워커 샤딩·재처리 정책을 한 곳에서 관리할 수 있다.
     - `CouponIssueResultListener`: `coupon:issue-stream`을 구독해 `couponRepository.save`와 `couponTemplateRepository.incrementIssuedQuantity`를 수행 후, 필요 시 REST Hook/SSE로 사용자에게 완료 알림.

7. **테스트 전략**
   - **단위 테스트**: `CouponIssueCoordinator` enqueue 시 Template/user 검증 실패, 대기열 등록 성공, 중복 등록 차단 등을 Embedded Redis로 검증.
   - **워커 통합 테스트**: Testcontainers Redis + 가짜 Repository로 스트림 소비 → RDB 저장까지 end-to-end 시나리오 작성.
   - **부하 테스트**: `k6/scenarios/coupon-issue.js`를 수정해 초당 10k 요청을 API에 투입하고, `queueRank` 응답 지연과 워커 처리량을 모니터링.

8. **운영 고려사항**
   - Redis 재기동 대비 AOF + replica 구성, `request-stream`/`issue-stream` 소비 지연 모니터링.
   - `queue-position` ZSET과 `issued` Set에 TTL을 설정해 이벤트 종료 후 자동 정리.
   - 워커 장애 시 `Pending Entries List`를 기반으로 재처리하며, 장기 미처리 건은 DLQ 스트림으로 이동.

9. **Next Action**
   1. `CouponIssueCoordinator`/워커/결과 컨슈머 모듈 스켈레톤 작성 및 레거시 서비스 의존성 제거.
   2. DTO/응답 스키마 변경 및 프론트엔드/클라이언트와 인터페이스 합의.
   3. 운영 대시보드(대기열 길이, consumer lag, 발급 성공률) 정의.
   4. 마이그레이션 단계에서 Redis 큐와 기존 RDB 발급 로직을 함께 모니터링할 수 있는 백필(batch) 작성.
