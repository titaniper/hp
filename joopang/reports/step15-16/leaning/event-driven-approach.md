# 이벤트 기반 방식 학습 정리

## 1. 개요
- 이벤트 기반(Event-driven) 방식은 상태 변화나 비즈니스 사실을 이벤트로 표현하고, 해당 이벤트를 트리거로 후속 작업을 수행하는 통신/처리 모델.
- Application Event, Domain Event, 메시지 브로커 기반 이벤트 등 구현 스펙트럼이 다양함.

## 2. 장점
- **결합도 감소**: 발행자와 구독자가 서로 직접 알 필요가 없어 시스템 간 의존성이 낮아진다.
- **확장성**: 이벤트를 비동기로 처리해 스파이크 트래픽을 흡수하고 수평 확장에 유리.
- **유연한 기능 확장**: 새로운 구독자를 추가하거나 기존 이벤트를 재활용하기 쉬움.
- **관심사 분리**: 핵심 로직과 부가 로직(알림, 데이터 동기화 등)을 분리하고 독립적으로 배포 가능.

## 3. 단점 / 고려사항
- **관측/디버깅 난이도**: 이벤트 경로가 분산되어 있어 추적이 어렵고, 분산 트레이싱/로그가 필수.
- **순서/중복 처리**: 이벤트가 중복 전달되거나 순서가 바뀔 수 있어 idempotent 컨슈머 설계 필요.
- **일관성 모델**: 결과적 일관성을 수용해야 하며, 사용자 경험에서 지연을 허용할 로직을 판단해야 함.
- **운영 복잡도**: 브로커 관리, Dead Letter Queue, 재시도 정책 등의 운영비용이 발생.

## 4. 관련 지식
- Pub/Sub 모델, 메시지 브로커(Kafka, RabbitMQ, Redis Stream).
- CQRS, Event Sourcing, Outbox 패턴, Saga 등 연관 아키텍처 패턴.
- Idempotency 키, 멱등 처리 전략, 재시도/백오프 알고리즘.

## 5. 예시
1. **사용자 가입 이벤트**: `UserRegistered` 이벤트 발행 → 이메일 알림, CRM 적재, 통계 업데이트 등 여러 구독자 실행.
2. **결제 승인 이벤트**: 결제 서비스가 `PaymentApproved` 발행 → 주문 서비스는 상태를 `PAID`로 변경, 재고 서비스는 출고 처리.
3. **로그 수집**: 애플리케이션이 이벤트를 발행하면 ELK/데이터 파이프라인이 비동기로 적재/분석.

## 6. 적용 가이드
- 이벤트 명명 규칙과 페이로드 스키마를 표준화해 진화 가능하게 설계.
- 이벤트 처리 실패 시 재시도/보류/보상 등의 플로우를 문서화하고 모니터링 지표로 연결.
- 이벤트가 실제 비즈니스 SLA에 미치는 영향(지연 허용 범위)을 정의하여 사용자 경험을 보호.
