# 시니어 엔지니어 멘토링 질문 리스트 (Step 15-16)

## 1. 이벤트 기반 관심사 분리
- `@TransactionalEventListener(AFTER_COMMIT)`로 후속 작업을 떼어낼 때, 이벤트 핸들러가 다시 트랜잭션을 열어야 하는 경우 어떤 기준으로 `REQUIRES_NEW` 혹은 비트랜잭션 모드를 선택하시는지 궁금합니다.
- Application Event를 다층으로 중첩해 사용하면 디버깅이 어려운데, 시니어분들은 이벤트 플로우를 어떻게 시각화/추적하고 있는지(예: Observation, TraceId 전파) 베스트 프랙티스를 듣고 싶습니다.
- 이벤트 순서를 보장해야 할 때 `@Order` 외에 추천하시는 패턴(예: Aggregate Root에서 Stage별 이벤트 발행 등)이 있다면 어떤 식으로 설계하시는지요?
- 이벤트 핸들러가 외부 API 호출을 포함할 때, 실패를 원 트랜잭션에 묶지 않으면서 재시도를 설계하는 표준 패턴(Outbox, Retry Topic 등)은 무엇인지 궁금합니다.

## 2. 트랜잭션 경계 진단 및 보상 전략
- 긴 트랜잭션을 쪼갤 때 “컷오프” 기준을 어떻게 잡으시는지(예: DB 락 유지 시간, I/O 개수, SLA 등) 정량화된 지표가 있으면 공유 부탁드립니다.
- 트랜잭션을 나눈 후 사이드 이펙트가 생겼는지 빠르게 검출하는 방법(예: Saga Orchestrator 로그, 보상 트랜잭션 대시보드)이 궁금합니다.
- 보상 트랜잭션이 필요한 시점을 어떻게 정의하시는지, 그리고 실제로는 어느 수준까지 자동화(스케줄러 / 관리자 승인)해 운영하는지 사례가 듣고 싶습니다.
- 분산락/Optimistic Lock 중 어떤 전략을 먼저 적용하고, 어떤 시그널이 드러날 때 다음 전략으로 넘어가야 하는지 현업 기준을 듣고 싶습니다.

## 3. Redis와 이벤트 조합
- 주문/결제 이벤트를 Redis Stream으로 넘기는 대신 Spring Event로만 처리하다가 나중에 메시지 브로커로 전환할 때, 코드 구조를 어떻게 설계하면 마이그레이션 비용이 최소화되는지 조언을 듣고 싶습니다.
- Redis Sorted Set으로 유지하던 인기 상품 집계를 이벤트 기반 배치와 혼용할 경우, “실시간 zIncrBy”와 “주기적 재계산” 간 충돌을 어떻게 방지하셨는지 궁금합니다.
- 쿠폰 템플릿 메타 데이터를 Redis Hash로 캐싱했는데, TTL 만료 시점에 트래픽이 몰리면 캐시 스탬피드가 발생할 수 있습니다. 시니어분들은 이런 메타 캐시에 대해 어떤 Warmup/Soft TTL 전략을 사용하시는지요?
- Stream 큐에서 이미 중복 필터링을 해도 악성 요청이 계속 들어올 때, 프론트/백엔드 어느 레이어에서 Rate Limit를 두는 것이 운영상 낫다고 보시는지 의견을 듣고 싶습니다.

## 4. 이벤트-트랜잭션 모니터링
- “트랜잭션 본체 → 이벤트 핸들러”로 나뉜 로직의 실패율을 각각 추적하기 위해 어떤 APM 계측(Span Naming, Custom Metric)을 적용하시는지 궁금합니다.
- 이벤트 기반으로 전환한 뒤 DB Lock 시간이 줄었는지 검증하려면 어떤 SQL/DB 메트릭을 우선 관찰해야 할까요? (예: pg_locks, MySQL Performance Schema 등)
- Redis Stream 컨슈머 그룹의 PEL과 Spring Event 리스너의 예외를 한 눈에 볼 수 있는 관측 지표를 구성하셨다면 어떤 지표를 추천하시는지 듣고 싶습니다.

## 5. 아키텍처/조직 운영
- 대규모 트랜잭션 분리 작업을 진행할 때, 도메인 팀과 플랫폼 팀의 역할 분담을 어떻게 구분하시는지(예: 이벤트 인프라, 모니터링 구성) 경험을 듣고 싶습니다.
- 이벤트 기반 구조로 바꾸면 배포/롤백 전략도 달라지는데, 실제로는 어떤 환경에서 피처 토글이나 Dual-Run 전략을 사용하시는지 궁금합니다.
- 장기적으로 MSA를 염두에 두고 있다면, 현재 Application Event 레벨에서 미리 준비해두면 좋은 표준(메시지 스키마, 도메인 이벤트 명명 규칙 등)이 무엇인지 조언 부탁드립니다.

## 6. 추가 딥다이브 질문
1. Redis Sorted Set으로 하루/시간 단위 키를 운영할 때, `ZUNIONSTORE` 결과를 RENAME 하기 직전에 장애가 나면 키 손실 가능성이 있는데 이를 방지하기 위한 double-write 혹은 checksum 전략이 있는지 궁금합니다.
2. Stream 기반 쿠폰 큐에서 `XACK` 이전에 컨슈머가 죽을 경우 PEL이 쌓이는데, 일정 시간 동안 idle 상태인 PEL 레코드를 재할당할 때 어떤 기준(Idle time, Retry count)을 적용하시는지요?
3. Application Event와 Kafka 이벤트를 동시에 발행해야 할 때 Outbox 패턴을 쓰면 Latency가 증가하는데, 실무에서는 어떤 방식으로 트랜잭션과 Outbox 처리의 지연을 허용 가능한 수준으로 유지하시는지 궁금합니다.
4. Redis Hash를 쿠폰 템플릿 캐시로 사용할 때 필드 수가 증가하면 HGETALL 비용이 커집니다. 실제 운영에서는 필요한 필드만 읽기 위해 어떤 키 설계 또는 `HScan` 전략을 쓰시는지요?
5. 트랜잭션 경계 밖에서 외부 API를 호출할 때, idempotency를 보장하기 위해 어떤 키(예: `orderId:targetSystem`)를 어디에 저장해두는 것이 실전에서 가장 유지보수하기 쉬웠는지 사례를 듣고 싶습니다.
6. 인기 상품 랭킹을 재계산하는 배치를 돌릴 때, Redis 메모리 파편화나 RDB/AOF 스냅샷으로 인한 GC/Stop-the-world 현상을 어떻게 모니터링하고 대응하셨는지 궁금합니다.
7. Spring `@TransactionalEventListener`가 기본적으로 동기 실행인데, 비동기로 전환(`@Async`)했을 때 쓰레드 풀 고갈이나 순서 보장 문제를 실무에서 어떻게 다뤘는지 듣고 싶습니다.
8. Redis를 캐시 이상의 1차 데이터 저장소로 사용할 때, 장애 후 복구 전까지 들어온 요청을 재처리하기 위한 로그(예: Kafka, CDC)를 어떻게 구성하는 것이 현실적인지 궁금합니다.
9. 분산락을 위해 Redisson이나 Lettuce 기반 구현을 사용할 때, 네트워크 파티션에서 락이 풀리지 않는 문제를 어떻게 모니터링하고 자동 해제하는지(심장박동? TTL 감지?) 경험을 듣고 싶습니다.
10. 이벤트 기반 구조에서 스키마 진화(필드 추가/삭제)를 안전하게 적용하기 위해, 시니어분들은 어떤 버전 관리 전략(예: Topic 버저닝, protobuf)과 배포 순서를 표준으로 삼으시는지 궁금합니다.
