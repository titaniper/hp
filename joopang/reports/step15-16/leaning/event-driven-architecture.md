# EDA(Event-Driven Architecture) 개요

## 1. 정의
- 시스템을 이벤트(Event)를 중심으로 설계하여, 이벤트 발행자와 구독자가 느슨하게 결합된 구조에서 상호작용하는 아키텍처 스타일.
- 이벤트는 상태 변화나 비즈니스 사실을 표현하며, 메시지 브로커/버스 등을 통해 전달된다.

## 2. 장점
- 서비스 간 결합도가 낮아 독립적인 배포/확장이 가능.
- 비동기 처리로 시스템 응답성을 높이고, 급증하는 트래픽을 완충.
- 새로운 구독자를 추가하기 쉽고, 기능 확장이 단순.

## 3. 단점 / 도전 과제
- 시스템 흐름을 추적하기 어렵고, 디버깅/테스트가 복잡해짐.
- 최종 일관성 모델을 수용해야 하며, 데이터 동기화 지연 가능.
- 메시지 순서 보장, 중복 처리, 재시도 정책 등 운영 복잡도가 상승.

## 4. 구성 요소
- **Event Producer**: 이벤트 발행 주체(서비스, 도메인).
- **Event Router/Broker**: Kafka, RabbitMQ, Redis Stream 등.
- **Event Consumer**: 이벤트를 구독해 비즈니스 로직 수행.
- **Schema Registry/Contract**: 이벤트 포맷을 정의하고 진화를 관리.

## 5. 예시
- **주문 시스템**: `OrderCreated` 이벤트를 발행하면 결제/재고/알림 서비스가 각자 구독해 로직을 수행.
- **IoT 센서**: 센서 이벤트를 수집해 실시간 분석/알림을 트리거.
- **로그/모니터링**: 애플리케이션 이벤트를 스트림으로 수집해 데이터 레이크/ELK 등으로 전송.

## 6. 운영 팁
- 이벤트 명명 규칙과 스키마 버저닝 전략을 문서화.
- Dead Letter Queue, 재시도 정책, 모니터링(Throughput, Lag)을 필수로 구성.
- 이벤트 중복/순서 문제를 해결하기 위해 idempotent 컨슈머 구현.
