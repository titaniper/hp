# [Chapter Review & Plan] 이벤트를 활용한 관심사 및 트랜잭션 분리

## 🔄 Summary: 지난 챕터 돌아보기 (Redis)

### 1. 캐싱 (Caching)
- **목적**: 조회 비용이 크거나 자주 변하지 않는 데이터를 빠르게 응답하기 위함.
- **효과**: DB I/O 감소, 애플리케이션 응답 속도 개선.
- **주의**: 비즈니스에 맞는 적절한 전략 필요 (부적절 시 관리 비용 증가, 데이터 오염 발생).

### 2. 분산락 (Distributed Lock)
- **목적**: 다건의 요청이 동시 접근/수정 시 발생하는 동시성 이슈 해결.
- **특징**: 
    - DB Connection을 점유하지 않아 대용량 트래픽의 완충 장치 역할.
    - 특정 데이터(row)에 국한되지 않는 복합적인 동시성 이슈 제어 가능.
- **예시**: 주문 완료 시 상품 A, B의 상태를 확인하고 구매 확정으로 변경하는 원자적 처리.

### 3. 레디스 자료구조 & 서비스 구현
- **자료구조**: String, List, Set, SortedSet, Hash 등 다양한 구조 활용.
- **구현 사례**:
    - **콘서트 대기열**: 트랜잭션 제어 및 유량 제어.
    - **선착순 쿠폰**: DB 부하 최소화.

> 💡 **Tip**: 레디스는 단순 캐시를 넘어 대용량 트래픽 처리를 위한 핵심 도구입니다. 면접 단골 질문이기도 하니 고도화된 활용법을 익혀둡시다.

---

## ⛵ 이번 챕터 목표: 이벤트를 활용한 관심사 및 트랜잭션 분리

1.  **트랜잭션 범위 파악**: 현재 구현된 비즈니스 로직 별 트랜잭션 범위와 사이드 이펙트 고려.
2.  **관심사 분리**: 애플리케이션 이벤트를 활용해 비즈니스 선후관계를 파악하고 관심사 분리.
3.  **도메인 간 트랜잭션**: 트랜잭션 분리 시 발생할 수 있는 문제와 해결 방법(보상 트랜잭션 등) 학습.

---

## 🚩 핵심 학습 내용: What to do

### 1. 비즈니스 로직과 트랜잭션의 범위 진단

**🔥 문제 상황 1: 하나의 트랜잭션이 너무 많은/오래 걸리는 작업을 처리**
- 전체 처리 시간 지연.
- DB Connection 및 Lock 점유 시간 증가로 인한 대기/데드락 유발.
- 긴 트랜잭션 중 후속 작업 실패 시 전체 롤백 리스크.

**🔥 문제 상황 2: 트랜잭션 내에 DB와 무관한 작업(외부 API 등) 포함**
- 외부 API 지연이 DB 트랜잭션 시간을 길어지게 함.
- 외부 작업 실패가 전체 비즈니스 로직(DB 반영)의 롤백을 유발 (무결성 문제).
- 타임아웃으로 롤백했으나 외부 시스템은 성공했을 경우 데이터 불일치 발생.

**💻 코드 개선 과정 (예시: 주문 결제 후 데이터 전송)**

1.  **AS-IS (강결합)**
    - 주문 정보 전달 실패 시 결제 로직까지 롤백됨.
    ```java
    @Transactional
    fun 주문_결제() { 
        유저_포인트_차감(); 
        결제_정보_저장(); 
        주문_상태_변경(); 
        주문_정보_전달(); // 문제 지점
    }
    ```

2.  **TO-BE (비동기 분리)**
    - `Async`로 분리하여 결제 로직 보호. 
    - **단점**: 핵심 로직과 부가 로직이 섞여 가독성 저하.
    ```java
    fun 주문_결제() { 
        execute_main(); // 핵심 로직
        Async { try { 주문_정보_전달() } catch { ... } } // 부가 로직
    }
    ```

3.  **BEST (이벤트 기반)**
    - `Event` 발행으로 관심사 완전 분리. 가독성 및 유지보수성 향상.
    ```java
    @Transactional
    fun 주문_결제() { 
        유저_포인트_차감(); 
        결제_정보_저장(); 
        주문_상태_변경(); 
        결제_완료_이벤트_발행(); 
    }
    
    @TransactionalEventListener(phase = AFTER_COMMIT)
    fun 주문_정보_전달(event) { ... }
    ```

### 2. Application Event (Spring / NestJS)

- **개념**: Event 발행/구독 모델을 통해 코드의 강한 결합을 분리.
- **장점**:
    - 비대해진 트랜잭션을 작은 단위로 분리.
    - 후속 작업을 Trigger 하는 방식으로 비즈니스 로직 단순화.
    - 부가 로직의 실패/지연이 메인 트랜잭션에 영향을 주지 않음.
- **주의사항**:
    - 작업 간 논리적 의존성 파악 (순서 등).
    - 파생 작업 실패 시 원본 작업 처리를 위한 **보상 트랜잭션**, **Saga 패턴**, **결과적 일관성** 고려 필요.

---

## 🗓️ 학습 로드맵

### 5일 로드맵 (상세)
- **Day 1**: 트랜잭션 범위 진단 (Lock 최소화, 사이드 이펙트 식별).
- **Day 2**: 비즈니스 로직 분리 (Async, Future 활용).
- **Day 3**: Application Event 도입 (`@TransactionalEventListener`, `AFTER_COMMIT`).
- **Day 4**: 이벤트 기반 시스템 통합 (다중 소비자, 실패 복구 전략).
- **Day 5**: MSA 대비 및 분산 트랜잭션 설계 (Saga, 보상 트랜잭션).

### 3시간 압축 가이드
1.  트랜잭션 구조 진단 & 부가 로직 분리 (45분).
2.  Application Event 구조와 흐름 이해 (45분).
3.  이벤트 기반 다중 로직 분리 및 실습 (45분).
4.  MSA 확장 대비 설계 & 보완 (45분).

---

## 📝 과제 (STEP 15-16)

### STEP 15: Application Event
- **목표**: 실시간 주문/예약 정보 전송 로직을 이벤트를 활용해 트랜잭션과 관심사를 분리.
- **평가 기준**:
    - 부가 로직이 핵심 로직에 영향을 주지 않는가?
    - 이벤트를 통해 관심사가 적절히 분리되었는가?

### STEP 16: Transaction Diagnosis
- **목표**: 도메인 분리(MSA 등) 시 발생할 트랜잭션 한계 식별 및 대응 방안 설계.
- **평가 기준**:
    - 도메인 배포 단위가 적절히 분리되었는가?
    - 분산 트랜잭션 문제(데이터 일관성 등)를 이해하고 해결책(Saga 등)을 제시했는가?

---

## ❓ Q&A 정리

**Q. 이벤트 기반 아키텍처의 단점(복잡도, 모니터링 등)에도 불구하고 사용하는 이유?**
> A. 도메인 간 강결합을 끊고, 배포 의존성을 줄여 독립적인 서비스 운영(MSA 등)을 가능하게 하기 위함입니다.

**Q. 레이어드 아키텍처에서 이벤트 관련 파일 위치?**
> A. `application` 레이어 (Facade, Usecase 레벨)에 Event, Publisher, Listener를 위치시키는 것을 권장합니다.

**Q. Kafka vs Application Event 구분?**
> A. 
> - **내부 로직 분리**: Spring Application Event 권장 (굳이 내부 로직을 위해 컨슈머를 띄울 필요 없음).
> - **외부 서비스 연동**: Kafka 등 메시지 브로커 권장.

**Q. 이벤트 유실 대비 (Outbox Pattern)?**
> A. Application Event는 메모리 기반이므로 실행 중 유실 가능성은 낮아 Outbox 패턴까지는 불필요합니다. (Kafka 등 외부 발행 시에는 고려).

**Q. 실패 이벤트 발행 필요성?**
> A. 해당 트랜잭션의 실패에 관심 있는 다른 도메인이 있다면 발행해야 하지만, 없다면 굳이 발행할 필요 없습니다.

**Q. 이벤트 리스너 순서 보장?**
> A. `@Order` 어노테이션 등을 통해 리스너 간 실행 순서를 제어할 수 있습니다.
