# MSA (Microservices Architecture)

## 1. MSA란 무엇인가?

**Microservices Architecture (MSA)**는 하나의 거대한 애플리케이션을 **작고 독립적인 여러 개의 서비스(Microservices)**로 나누어 개발, 배포, 유지보수하는 아키텍처 스타일입니다.

기존의 **Monolithic Architecture(모놀리식 아키텍처)**가 모든 기능을 하나의 프로젝트에 담아 통합된 형태로 개발되는 것과 대조적입니다. 모놀리식은 초기 개발이 빠르지만, 규모가 커질수록 빌드/배포 시간이 길어지고, 작은 수정사항이 전체 시스템에 영향을 줄 수 있으며, 특정 기능만 스케일아웃(Scale-out)하기 어려운 단점이 있습니다.

반면 MSA는 각 서비스가 독립적으로 실행되며, HTTP API(REST)나 메시지 큐(Message Queue) 같은 가벼운 통신 메커니즘을 통해 서로 통신합니다.

### MSA의 장점

* **배포 유연성**: 서비스별로 독립적인 배포가 가능하여 전체 시스템 중단 없이 업데이트가 가능합니다.
* **확장성 (Scalability)**: 트래픽이 많은 특정 서비스만 선택적으로 확장(Scale-out)할 수 있어 리소스 효율이 좋습니다.
* **기술 다양성**: 각 서비스의 목적에 맞는 최적의 언어, 프레임워크, 데이터베이스를 선택할 수 있습니다 (Polyglot Programming).
* **장애 격리**: 하나의 서비스에 장애가 발생해도 다른 서비스로 전파되지 않도록 격리할 수 있어 전체 시스템의 가용성이 높아집니다.

### MSA의 단점

* **복잡성 증가**: 분산 시스템이므로 서비스 간 통신, 트랜잭션 관리, 장애 처리 등이 복잡해집니다.
* **데이터 일관성**: 분산 데이터베이스 환경에서 데이터 정합성(Consistency)을 유지하기 위해 Saga 패턴 등의 복잡한 트랜잭션 관리가 필요합니다.
* **운영 비용**: 관리해야 할 서비스 인스턴스가 많아지므로 모니터링, 로깅, 배포 자동화 등 인프라 운영 비용이 증가합니다.

---

## 2. MSA가 갖춰야 하는 핵심 요소 (Components & Capabilities)

성공적인 MSA 구축을 위해서는 단순히 서비스를 나누는 것 외에도 분산 환경을 지탱할 수 있는 여러 인프라와 패턴이 필요합니다.

### 1) 서비스 독립성 및 분산 데이터 관리 (Database per Service)

* 각 마이크로서비스는 **자신만의 데이터베이스**를 가져야 합니다.
* 다른 서비스의 데이터베이스에 직접 접근하지 않고, 오직 API를 통해서만 데이터를 주고받아야 결합도(Coupling)를 낮출 수 있습니다.

### 2) API Gateway

* 클라이언트(Web, Mobile)가 여러 마이크로서비스를 직접 호출하는 대신, **단일 진입점** 역할을 하는 서버입니다.
* **역할**: 인증/인가, 라우팅, 로드 밸런싱, 프로토콜 변환, 로깅 등 공통 기능을 처리합니다.

### 3) Service Discovery

* 동적으로 생성되고 삭제되는 서비스 인스턴스들의 **IP 주소와 포트 정보를 관리**하고 찾아주는 기능입니다.
* 서비스가 시작될 때 자신의 위치를 등록(Registry)하고, 클라이언트나 게이트웨이가 이를 조회하여 통신합니다. (예: Netflix Eureka, Consul)

### 4) 장애 격리 및 회복 탄력성 (Fault Tolerance & Resilience)

* 특정 서비스의 장애가 전체 시스템으로 전파되는 것을 막아야 합니다.
* **Circuit Breaker**: 장애가 발생한 서비스로의 요청을 차단하여 대기 시간을 줄이고 시스템을 보호합니다. (예: Resilience4j)
* **Fallback**: 요청 실패 시 기본값을 반환하거나 대체 로직을 수행합니다.

### 5) 분산 트랜잭션 관리 (Saga Pattern)

* 여러 서비스에 걸친 비즈니스 로직을 처리할 때 데이터 일관성을 보장하기 위한 패턴입니다.
* 2PC(Two-Phase Commit) 대신, 각 서비스의 로컬 트랜잭션을 순차적으로 실행하고, 실패 시 보상 트랜잭션(Compensating Transaction)을 실행하여 롤백합니다.

### 6) 중앙 집중식 로깅 및 모니터링 (Centralized Logging & Monitoring)

* 수십, 수백 개의 서비스 로그를 개별 서버에서 확인하는 것은 불가능합니다.
* **ELK Stack (Elasticsearch, Logstash, Kibana)** 등을 통해 로그를 한곳에 모아 분석해야 합니다.
* **Tracing**: 분산 추적(Distributed Tracing) 도구(Zipkin, Jaeger)를 사용하여 하나의 요청이 여러 서비스를 거쳐가는 흐름을 추적해야 합니다.

### 7) CI/CD 자동화 (DevOps)

* 서비스가 많아질수록 수동 배포는 불가능에 가깝습니다.
* 빌드, 테스트, 컨테이너 이미지 생성, 배포 과정을 자동화해야 합니다. (Jenkins, GitHub Actions, ArgoCD 등)

---

## 3. MSA 예시: 이커머스 (E-commerce) 시스템

전통적인 쇼핑몰을 MSA로 전환한다고 가정했을 때의 구조 예시입니다.

### 서비스 분리

1. **사용자 서비스 (User Service)**: 회원 가입, 로그인, 프로필 관리.
2. **상품 서비스 (Product Service)**: 상품 등록, 수정, 재고 조회, 카테고리 관리.
3. **주문 서비스 (Order Service)**: 주문 생성, 주문 내역 조회, 취소.
4. **결제 서비스 (Payment Service)**: 결제 승인, 환불 처리, PG사 연동.
5. **배송 서비스 (Delivery Service)**: 배송 상태 추적, 운송장 관리.

### 시나리오: "사용자가 상품을 주문한다"

1. **Client** -> **API Gateway**: 주문 요청 전송.
2. **API Gateway**: 인증 토큰 확인 후 **주문 서비스**로 요청 라우팅.
3. **주문 서비스**:
    * **상품 서비스** API 호출 -> 재고 확인 및 차감.
    * **사용자 서비스** API 호출 -> 배송지 정보 확인.
    * 주문 데이터 생성 (Pending 상태).
4. **주문 서비스** -> **결제 서비스**: 결제 요청 이벤트 발행 (Kafka 등 메시지 큐 사용).
5. **결제 서비스**: 결제 처리 후 '결제 완료' 이벤트 발행.
6. **주문 서비스**: '결제 완료' 이벤트 수신 후 주문 상태를 'Complete'로 변경.
7. **배송 서비스**: '결제 완료' 이벤트 수신 후 배송 준비 시작.

이 과정에서 만약 **결제 서비스**가 다운되더라도, 사용자는 상품을 장바구니에 담거나 상품 목록을 보는(**상품 서비스**) 기능은 정상적으로 이용할 수 있습니다. 이것이 MSA의 핵심인 **장애 격리**입니다.
