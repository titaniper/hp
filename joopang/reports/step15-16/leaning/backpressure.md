# 백프레셔 (Backpressure)

## 1. 개념

- 데이터 스트림 처리에서 **데이터 생산자(Producer)의 속도가 소비자(Consumer)의 처리 속도를 초과할 때** 발생하는 문제를 제어하는 메커니즘.
- 소비자가 처리할 수 있는 양만큼만 데이터를 요청하거나, 초과되는 데이터를 제어하여 시스템의 안정성을 유지함.

## 2. 필요성

- 생산자가 너무 빠르게 데이터를 보내면 소비자의 버퍼가 넘쳐 **OOM(Out Of Memory)** 발생 가능.
- 시스템 과부하로 인한 전체 장애(Cascading Failure) 방지.
- 리소스의 효율적 사용.

## 3. 동작 방식 (Reactive Streams 기준)

- **Pull 방식 (Request-N)**: 소비자가 처리 가능한 데이터 개수(N)를 생산자에게 요청(Subscription.request(n)).
- 생산자는 요청받은 개수만큼만 데이터를 발행(onNext).
- 소비자가 처리를 완료하면 다시 데이터를 요청.

## 4. 처리 전략

### 4.1 버퍼링 (Buffering)

- 소비자가 처리할 때까지 큐(Queue)에 데이터를 임시 저장.
- **주의**: 버퍼가 가득 차면 메모리 부족 문제가 발생할 수 있음 (Bounded Queue 사용 권장).

### 4.2 드랍 (Dropping)

- 버퍼가 가득 차거나 처리 속도를 못 따라갈 때, 들어오는 데이터를 버림.
- 최신 데이터가 중요한 경우(예: 주식 시세) 오래된 데이터를 버리거나, 반대로 신규 데이터를 버릴 수 있음.

### 4.3 에러 발생 (Fail)

- 처리 불가능한 상황이 되면 즉시 에러를 발생시켜 생산자에게 알림.

### 4.4 조절 (Throttling / Rate Limiting)

- 일정 시간 동안 처리할 수 있는 데이터 양을 제한하거나, 샘플링하여 일부만 처리.

## 5. 적용 사례

- **Project Reactor (Java)**: `Flux`의 `onBackpressureBuffer`, `onBackpressureDrop`, `limitRate` 등의 연산자 제공.
- **Kafka**: Consumer가 메시지를 Pull 해가는 방식으로 자연스럽게 백프레셔가 적용됨 (처리 가능한 만큼만 가져감).
- **Network Flow Control**: TCP의 윈도우 사이즈 조절.

## 6. 아키텍처 관점의 백프레셔 (브로커 + 컨슈머)

질문하신 **"브로커 저장소 + 컨슈머 패러다임"**은 시스템 아키텍처 레벨에서 백프레셔를 구현하는 가장 대표적인 방법입니다.

### 6.1 동작 원리

1. **생산자(Producer)**는 데이터를 브로커(Kafka, RabbitMQ 등)로 전송합니다.
1. **브로커(Broker)**는 이 데이터를 디스크나 메모리에 **버퍼링(저장)**합니다.
1. **소비자(Consumer)**는 자신의 처리 능력에 맞춰 브로커로부터 데이터를 **가져갑니다(Pull)**.

### 6.2 백프레셔로서의 특징

- **비동기 버퍼링**: 브로커가 거대한 버퍼 역할을 하여, 생산자가 갑자기 많은 데이터를 보내도 소비자가 즉시 압도되지 않습니다.
- **소비자 주도권 (Pull Model)**: 소비자가 준비되었을 때만 데이터를 요청하므로, `OOM`이나 장애 없이 안정적으로 동작합니다.
- **시간적 결합 분리**: 생산과 소비의 속도 차이를 브로커가 흡수하여, 시스템 전체의 유연성을 높입니다.
